//
// Created by Shujian Qian on 2023-08-23.
//

#ifndef TPCC_TXN_H
#define TPCC_TXN_H

#include <cstdlib>

#include "txn.h"

namespace epic::tpcc {

enum class TpccTxnType : uint32_t
{
    NEW_ORDER = 1,
    PAYMENT,
    ORDER_STATUS,
    DELIVERY,
    STOCK_LEVEL
};

struct FixedSizeTxn
{
    static constexpr size_t kMaxItems = 15;
};

struct VariableSizeTxn
{
    static constexpr size_t kMaxItems = 0;
};

/**
 * This is generated during the batching process and used by the indexer.
 *
 * @tparam TxnType
 */
template<typename TxnType>
struct NewOrderTxnInput
{
    struct ItemIndex
    {
        uint32_t i_id;
        uint32_t w_id;
        uint32_t order_quantities;
    };
    uint32_t origin_w_id;
    uint32_t d_id;
    uint32_t c_id;
    uint32_t o_id;
    uint32_t num_items;
    ItemIndex items[TxnType::kMaxItems];
};

/**
 * This is generated by the indexer through indexing the batched transaction.
 * It is used by the execution planner as well as the execution engine (along with the execution plan).
 *
 * @tparam TxnType
 */
template<typename TxnType>
struct NewOrderTxnParams
{
    struct ItemParams
    {
        uint32_t item_id;  /* i_id */
        uint32_t stock_id; /* w_id, i_id */
        uint32_t order_line_id;
        uint32_t order_quantities;
    };
    uint32_t warehouse_id; /* w_id */
    uint32_t district_id;  /* w_id, d_id */
    uint32_t customer_id;  /* w_id, d_id, c_id */
    uint32_t new_order_id; /* w_id, d_id, o_id */
    uint32_t order_id;     /* w_id, d_id, o_id */
    uint32_t num_items;
    uint32_t next_order_id;
    bool all_local;
    ItemParams items[TxnType::kMaxItems];
};

/**
 * This is generated by the execution planner and used by the execution engine.
 *
 * @tparam TxnType
 */
template<typename TxnType>
struct NewOrderExecPlan
{
    struct ItemPlan
    {
        uint32_t item_loc;
        uint32_t stock_read_loc;
        uint32_t stock_write_loc;
        uint32_t orderline_loc;
    };
    uint32_t warehouse_loc;
    uint32_t district_loc;
    uint32_t district_write_loc;
    uint32_t customer_loc;
    uint32_t new_order_loc;
    uint32_t order_loc;
    ItemPlan item_plans[TxnType::kMaxItems];
};

struct PaymentTxnInput
{
    uint32_t warehouse_id;
    uint32_t district_id;
    uint32_t customer_warehouse_id;
    uint32_t customer_district_id;
    uint32_t payment_amount;
    uint32_t customer_id;
};

struct PaymentTxnParams
{
    uint32_t warehouse_id;
    uint32_t district_id;
    uint32_t customer_id;
    uint32_t payment_amount;
};

struct PaymentTxnExecPlan
{
    uint32_t warehouse_read_loc;
    uint32_t warehouse_write_loc;
    uint32_t district_read_loc;
    uint32_t district_write_loc;
    uint32_t customer_read_loc;
    uint32_t customer_write_loc;
};

struct OrderStatusTxnInput
{
    /* TODO: implement order-status txn */
    uint32_t w_id;
    uint32_t d_id;
    uint32_t c_id;
    uint32_t o_id;
    uint32_t num_items;
};

struct OrderStatusTxnParams
{
    uint32_t customer_id;
    uint32_t order_id;
    uint32_t num_items;
    uint32_t orderline_ids[15];
};

struct OrderStatusTxnExecPlan
{
    uint32_t customer_loc;
    uint32_t order_loc;
    uint32_t orderline_locs[15];
};

struct DeliveryTxnInput
{
    uint32_t w_id;
    uint32_t carrier_id;
    uint32_t delivery_d;
    uint32_t o_id; // since the deliver order delivers all districts, the order id is the same across all districts
    uint32_t num_items[10];
    uint32_t customers[10];
};

struct DeliveryTxnParams
{
    uint32_t carrier_id;
    uint32_t delivery_d;
    uint32_t new_order_id[10];
    uint32_t order_id[10];
    uint32_t customer_id[10];
    uint32_t orderline_ids[10][15];
    uint32_t num_items[10];
};

struct DeliveryTxnExecPlan
{
    uint32_t new_order_read_locs[10];
    uint32_t order_read_locs[10];
    uint32_t order_write_locs[10];
    uint32_t customer_read_locs[10];
    uint32_t customer_write_locs[10];
    uint32_t orderline_read_locs[10][15];
    uint32_t orderline_write_locs[10][15];
};

struct StockLevelTxnInput
{
    uint32_t w_id;
    uint32_t d_id;
    uint32_t o_id; // order id of the last txn in the district, will check the last 20 txns
    uint32_t threshold;
    uint32_t num_items;
    // uint32_t items[300]; /* cpu_aux_index replaced by gpu_aux_index */
};

struct StockLevelTxnParams
{
    uint32_t num_items;
    uint32_t threshold;
    uint32_t num_low_stock;
    uint32_t stock_ids[304]; /* this should be a multiple of 16 for gpu_aux_index WarpMergeSort */
};

struct StockLevelTxnExecPlan
{
    uint32_t stock_read_locs[300];
};

/**
 * Make is easier to calculate the size of the largest txn.
 */
union TpccTxn
{
    NewOrderTxnInput<FixedSizeTxn> new_order_txn;
    PaymentTxnInput payment_txn;
    OrderStatusTxnInput order_status_txn;
    DeliveryTxnInput delivery_txn;
    StockLevelTxnInput stock_level_txn;
};

union TpccTxnParam
{
    NewOrderTxnParams<FixedSizeTxn> new_order_txn;
    PaymentTxnParams payment_txn;
    OrderStatusTxnParams order_status_txn;
    DeliveryTxnParams delivery_txn;
    StockLevelTxnParams stock_level_txn;
} __attribute__((aligned(4)));

union TpccExecPlan
{
    NewOrderExecPlan<FixedSizeTxn> new_order_txn;
    PaymentTxnExecPlan payment_txn;
    OrderStatusTxnExecPlan order_status_txn;
    DeliveryTxnExecPlan delivery_txn;
    StockLevelTxnExecPlan stock_level_txn;
} __attribute__((aligned(4)));

/* TODO: how to implement piece exection on GPU? */
void runTransaction(BaseTxn *txn);
void runTransaction(NewOrderTxnInput<FixedSizeTxn> *txn);
void runTransaction(PaymentTxnInput *txn);
void runTransaction(OrderStatusTxnInput *txn);
void runTransaction(DeliveryTxnInput *txn);

template <typename TxnType>
using TpccBaseTxnArrayT = PackedTxnArray<TxnType>;
using TpccTxnArrayT = TpccBaseTxnArrayT<TpccTxn>;
using TpccTxnParamArrayT = TpccBaseTxnArrayT<TpccTxnParam>;
using TpccTxnExecPlanArrayT = TpccBaseTxnArrayT<TpccExecPlan>;

// template <typename SrcTxnType, typename DestTxnType>
// void buildPackedTxnArrayGpu(PackedTxnArray<SrcTxnType> &src, PackedTxnArray<DestTxnType> &dest) {}
//
// template <>
// void buildPackedTxnArrayGpu(PackedTxnArray<TpccTxn> &src, PackedTxnArray<TpccTxnParam> &dest);
// template <>
// void buildPackedTxnArrayGpu(PackedTxnArray<TpccTxn> &src, PackedTxnArray<TpccExecPlan> &dest);

class TpccPackedTxnArrayBuilder
{
    uint32_t num_txns;
    uint32_t *temp_storage = nullptr;
    uint32_t *txn_sizes = nullptr;
    size_t temp_storage_bytes = 0;
public:
    explicit TpccPackedTxnArrayBuilder(uint32_t num_txns);

    template <typename SrcTxnType, typename DestTxnType>
    void buildPackedTxnArrayGpu(PackedTxnArray<SrcTxnType> &src, PackedTxnArray<DestTxnType> &dest)
    {
        throw std::runtime_error("build Packed Txn Array is not implemented for the input types");
    }
};

template<>
void TpccPackedTxnArrayBuilder::buildPackedTxnArrayGpu(
    PackedTxnArray<TpccTxn> &src, PackedTxnArray<TpccTxnParam> &dest);
template<>
void TpccPackedTxnArrayBuilder::buildPackedTxnArrayGpu(
    PackedTxnArray<TpccTxn> &src, PackedTxnArray<TpccExecPlan> &dest);

} // namespace epic::tpcc

#endif // TPCC_TXN_H
